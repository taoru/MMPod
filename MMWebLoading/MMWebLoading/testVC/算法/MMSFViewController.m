//
//  MMSFViewController.m
//  MMWebLoading
//
//  Created by iMac on 15/9/6.
//  Copyright (c) 2015年 Alan. All rights reserved.
//

#import "MMSFViewController.h"

@implementation MMSFViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    /*
    1、插入排序
    
    在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
    
    直接插入排序是稳定的。算法时间复杂度O(n2)--[n的平方]
    main()
    
    {
        
        int  a[10],j,i,m;
        
        for(j=1;j<10;j++)
            
        {
            
            m=a[j];
            
            for(i=j-1;i>=0;i--)
                
            {
                
                if(a[i]<m)
                    
                    break;
                
                else
                    
                    a[i+1]=a[i];
                
            }
            
            a[i+1]=m;
            
        }
        
    }
    */
    
    
    /*
    2、希尔排序
    
    D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。
    
    下面的函数是一个希尔排序算法的一个实现，初次取序列的一半为增量，
    
    以后每次减半，直到增量为1。
    
    希尔排序是不稳定的。
    
    
    
    void shell_sort(int *x, int n)
    
    {
        
        int h, j, k, t;
        
        for (h=n/2; h>0; h=h/2) /控制增量
            
        {
            
            for (j=h; j<n; j++) //这个实际上就是上面的直接插入排序
                
            {
                
                t = *(x+j);
                
                for (k=j-h; (k>=0 && t<*(x+k)); k-=h)
                    
                {
                    
                    if(*(x+k)<t)
                        
                        break;
                    
                    else
                        
                        *(x+k+h) = *(x+k);
                    
                }
                
                *(x+k+h) = t;
                
            }
            
        }
        
    }
    */


    //3、冒泡排序  在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。  O(n2)
    [self sort3];


    /*4、快速排序
    
    快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保以某个数为基准点的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。
    显然快速排序可以用递归实现，当然也可以用栈化解递归实现。
    快速排序是不稳定的。最理想情况算法时间复杂度O(nlog2n)，最坏O(n2)
   */
    
    /*5、选择排序
     
     在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。
     
     选择排序是不稳定的。算法复杂度O(n2)--[n的平方]
     */
    [self sort5];
    
    
}
-(void)sort3
{
    
    int a[10],i,j,k;
    
    for(i=0;i<9;i++)
        
        for(j=0;j<10-i;j++)
            
            if(a[j]>a[j+1])
                
            {
                
                k=a[j];
                
                a[j]=a[j+1];
                
                a[j+1]=k;
                
            }
    
}
-(void)sort5

{
    
    int t,k,i,j,a[10];
    
    for(i=0;i<9;i++)
        
    {
        
        k=i;
        
        for(j=i+1;j<10;j++)
            
            if(a[k]>a[j])
                
                k=j;
        
        t=a[i];
        
        a[i]=a[k];
        
        a[k]=t;
        
    }
    
}
@end
